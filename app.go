package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	_ "net/http/pprof"
	"os"
	"os/signal"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/Financial-Times/message-queue-gonsumer/consumer"
	"github.com/Financial-Times/publish-availability-monitor/content"
	log "github.com/Sirupsen/logrus"
	"github.com/gorilla/mux"
	"github.com/jawher/mow.cli"
)

// AppConfig holds the application's configuration
type AppConfig struct {
	QueueConf consumer.QueueConfig `json:"queueConfig"`
	SlackURL  string
}

type slackPayload struct {
	Channel     string            `json:"channel"`
	Username    string            `json:"username"`
	Text        string            `json:"text"`
	IconEmoji   string            `json:"icon_emoji"`
	Attachments []slackAttachment `json:"attachments"`
}

type slackAttachment struct {
	Fallback string       `json:"fallback"`
	Pretext  string       `json:"pretext"`
	Color    string       `json:"color"`
	Fields   []slackField `json:"fields"`
}

type slackField struct {
	Title string `json:"title"`
	Value string `json:"value"`
	Short bool   `json:"short"`
}

const dateLayout = time.RFC3339Nano

var appConfig AppConfig

func main() {
	app := cli.App("up-river-of-news", "Listens for native publication events and posts them to a slack channel")
	port := app.IntOpt("port", 8080, "Port to listen on")
	//env := app.StringOpt("env", "local", "environment this app is running in")

	app.Action = func() {
		appConfig = setUpAppConfig()
		go enableHealthchecks(*port)
		readMessages()
	}

	log.SetLevel(log.InfoLevel)
	log.Infof("Application started with args %s", os.Args)
	app.Run(os.Args)
}

func enableHealthchecks(port int) {

	healthcheck := &Healthcheck{http.Client{}, appConfig}
	router := mux.NewRouter()
	router.HandleFunc("/__health", healthcheck.checkHealth())
	router.HandleFunc("/__gtg", healthcheck.gtg)
	http.Handle("/", router)
	err := http.ListenAndServe(fmt.Sprintf(":%d", port), nil)
	if err != nil {
		log.Panicf("Couldn't set up HTTP listener: %+v\n", err)
	}
}

func readMessages() {
	log.Infof("Starting to read messages with queue config=%v", appConfig.QueueConf)
	c := consumer.NewConsumer(appConfig.QueueConf, handleMessage, http.Client{})

	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		c.Start()
		wg.Done()
	}()

	ch := make(chan os.Signal)
	signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)
	<-ch
	c.Stop()
	wg.Wait()
}

func handleMessage(msg consumer.Message) {
	tid := msg.Headers["X-Request-Id"]
	log.Debugf("Received message with TID [%v]", tid)

	if isSyntheticMessage(tid) {
		log.Debugf("Message [%v] is a synthetic publication, skipping...", tid)
		return
	}

	publishedContent, err := content.UnmarshalContent(msg)
	if err != nil {
		log.Warnf("Cannot unmarshal message [%v], error: [%v]", tid, err.Error())
		return
	}

	uuid := publishedContent.GetUUID()
	if !publishedContent.IsValid() {
		log.Infof("Message [%v] with UUID [%v] is INVALID, skipping...", tid, uuid)
		return
	}

	publishDateString := msg.Headers["Message-Timestamp"]
	publishDate, err := time.Parse(dateLayout, publishDateString)
	if err != nil {
		log.Errorf("Cannot parse publish date [%v] from message [%v], error: [%v]",
			publishDateString, tid, err.Error())
		return
	}

	log.Infof("Content published, uuid=%s, publishDate=%v", uuid, publishDate)

	//TODO work out if it's been created, updated or deleted (use
	//publishedContent.IsMarkedDeleted()
	//TODO get the headline (which I don't think is available - change the content package??)
	//TODO get the REAL publish date

	if publishedContent.GetType() != "Image" {
		notifySlack(uuid, tid, publishDateString)
	}
}

func notifySlack(uuid string, tid string, publishDate string) error {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	data := slackPayload{
		//Channel:   "@sarah.wells", //use this if you want to override to another channel
		Username:  "UPP Publication Event",
		Text:      fmt.Sprintf("An article has been published. <http://spyglass.ft.com/view/%s?env=prod|See it on Spyglass>", uuid),
		IconEmoji: ":newspaper:",
		Attachments: []slackAttachment{{
			Fallback: fmt.Sprintf("Published timestamp=%v, TransactionID=%v", publishDate, tid),
			Color:    "good",
			Fields: []slackField{{
				Title: "Published at",
				Value: publishDate,
				Short: true,
			}, {
				Title: "TransactionId",
				Value: tid,
				Short: true,
			}, {
				Title: "UUID",
				Value: uuid,
				Short: true,
			}},
		}},
	}

	payloadBytes, err := json.Marshal(data)
	if err != nil {
		return err
	}
	body := bytes.NewReader(payloadBytes)

	req, err := http.NewRequest("POST", appConfig.SlackURL, body)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		log.Errorf("Could not post payload %v to slack on url=%s", data, appConfig.SlackURL)
		return err
	}
	defer resp.Body.Close()
	return nil
}

func isMessagePastPublishSLA(date time.Time, threshold int) bool {
	passedSLA := date.Add(time.Duration(threshold) * time.Second)
	return time.Now().After(passedSLA)
}

func isSyntheticMessage(tid string) bool {
	return strings.HasPrefix(tid, "SYNTHETIC")
}

func setUpAppConfig() AppConfig {
	appConfig := AppConfig{QueueConf: consumer.QueueConfig{
		Addrs: []string{
			"http://kafka-proxy-TODO",
			//"http://kafka-proxy-01-iw-uk-p.in.ft.com:8080",
			//	"http://kafka-proxy-02-iw-uk-p.in.ft.com:8080"
		},
		Group: "RiverOfNews",
		Topic: "NativeCmsPublicationEvents",
		//TODO check what smallest vs largest actually does
		//Offset:               "<set to `smallest` otherwise the default `largest` will be considered>",
		ConcurrentProcessing: false, //TODO - what is the implication? I'm assuming I want this in strict order
		//TODO work out where this will be deployed and whether I need this
		//AuthorizationKey:     "<required from AWS to UCS>",
		AutoCommitEnable: true,
	},
		SlackURL: "https://hooks.slack.com/services/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"}
	log.Infof("config=%v", appConfig)

	return appConfig
}
